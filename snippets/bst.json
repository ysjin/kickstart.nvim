{
  "Insert in BST": {
    "prefix": "insBst",
    "body": [
      "Node *insertBST(Node *root, int val)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return new Node(val);",
      "    }",
      "    if (val < root->data)",
      "    {",
      "        root->left = insertBST(root->left, val);",
      "    }",
      "    else",
      "    {",
      "        root->right = insertBST(root->right, val);",
      "    }",
      "    return root;",
      "}"
    ],
    "description": "Insert in BST"
  },
  "Delete in BST": {
    "prefix": "delBst",
    "body": [
      "Node *inorderSucc(Node *root)",
      "{",
      "    Node *curr = root;",
      "    while (curr && curr->left != NULL)",
      "    {",
      "        curr = curr->left;",
      "    }",
      "    return curr;",
      "}",
      "Node *deleteInBST(Node *root, int key)",
      "{",
      "    if (key < root->data)",
      "    {",
      "        root->left = deleteInBST(root->left, key);",
      "    }",
      "    else if (key > root->data)",
      "    {",
      "        root->right = deleteInBST(root->right, key);",
      "    }",
      "    else",
      "    {",
      "        if (root->left == NULL)",
      "        {",
      "            Node *temp = root->right;",
      "            free(root);",
      "            return temp;",
      "        }",
      "        else if (root->right == NULL)",
      "        {",
      "            Node *temp = root->left;",
      "            free(root);",
      "            return temp;",
      "        }",
      "        Node *temp = inorderSucc(root->right);",
      "        root->data = temp->data;",
      "        root->right = deleteInBST(root->right, temp->data);",
      "    }",
      "    return root;",
      "}"
    ],
    "description": "Delete in BST"
  },
  "Search in BST": {
    "prefix": "searchBst",
    "body": [
      "Node *searchInBST(Node *root, int key)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return NULL;",
      "    }",
      "    if (root->data == key)",
      "    {",
      "        return root;",
      "    }",
      "    if (root->data > key)",
      "    {",
      "        return searchInBST(root->left, key);",
      "    }",
      "    return searchInBST(root->right, key);",
      "}"
    ],
    "description": "Search in BST"
  },
  "Construct BST": {
    "prefix": "constructBst",
    "body": [
      "Node *constructBST(int preorder[], int *preorderIdx, int key, int min, int max, int n)",
      "{",
      "    if (*preorderIdx >= n)",
      "    {",
      "        return NULL;",
      "    }",
      "    Node *root = NULL;",
      "    if (key > min && key < max)",
      "    {",
      "        root = new Node(key);",
      "        *preorderIdx = *preorderIdx + 1;",
      "        if (*preorderIdx < n)",
      "        {",
      "            root->left = constructBST(preorder, preorderIdx, preorder[*preorderIdx], min, key, n);",
      "        }",
      "        if (*preorderIdx < n)",
      "        {",
      "            root->right = constructBST(preorder, preorderIdx, preorder[*preorderIdx], key, max, n);",
      "        }",
      "    }",
      "    return root;",
      "}"
    ],
    "description": "Construct BST"
  },
  "Check the given tree is BST or not": {
    "prefix": "isBst",
    "body": [
      "bool isBST(Node *root, Node *min = NULL, Node *max = NULL)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return true;",
      "    }",
      "    if (min != NULL && root->data <= min->data)",
      "    {",
      "        return false;",
      "    }",
      "    if (max != NULL && root->data >= max->data)",
      "    {",
      "        return false;",
      "    }",
      "    bool leftValid = isBST(root->left, min, root);",
      "    bool rightValid = isBST(root->right, root, max);",
      "",
      "    return leftValid and rightValid;",
      "}"
    ],
    "description": "Check the given tree is BST or not"
  },
  "Sorted array to Bst": {
    "prefix": "sortArrToBst",
    "body": [
      "Node *sortedArrToBST(int a[], int start, int end)",
      "{",
      "    if (start > end)",
      "    {",
      "        return NULL;",
      "    }",
      "",
      "    int mid = (start + end) / 2;",
      "    Node *root = new Node(a[mid]);",
      "",
      "    root->left = sortedArrToBST(a, start, mid - 1);",
      "    root->right = sortedArrToBST(a, mid + 1, end);",
      "",
      "    return root;",
      "}"
    ],
    "description": "Sorted array to Bst"
  },
  "Is Bst identical or nor": {
    "prefix": "isIdentical",
    "body": [
      "bool isIdentical(Node *root1, Node *root2)",
      "{",
      "    if (root1 == NULL && root2 == NULL)",
      "    {",
      "        return true;",
      "    }",
      "    else if (root1 == NULL || root2 == NULL)",
      "    {",
      "        return false;",
      "    }",
      "    else",
      "    {",
      "        bool c1 = root1->data == root2->data;",
      "        bool c2 = isIdentical(root1->left, root2->left);",
      "        bool c3 = isIdentical(root1->right, root2->right);",
      "",
      "        if (c1 && c2 && c3)",
      "        {",
      "            return true;",
      "        }",
      "        else",
      "        {",
      "            return false;",
      "        }",
      "    }",
      "}"
    ],
    "description": "Is Bst identical or nor"
  },
  "zigzagTraversal Bst": {
    "prefix": "zigzagTraversal",
    "body": [
      "void zigzagTraversal(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return;",
      "    }",
      "    stack<Node *> currLevel;",
      "    stack<Node *> nextLevel;",
      "",
      "    bool leftToRight = true;",
      "",
      "    currLevel.push(root);",
      "    while (!currLevel.empty())",
      "    {",
      "        Node *temp = currLevel.top();",
      "        currLevel.pop();",
      "",
      "        if (temp)",
      "        {",
      "            cout << temp->data << \" \";",
      "            if (leftToRight)",
      "            {",
      "                if (temp->left)",
      "                {",
      "                    nextLevel.push(temp->left);",
      "                }",
      "                if (temp->right)",
      "                {",
      "                    nextLevel.push(temp->right);",
      "                }",
      "            }",
      "            else",
      "            {",
      "                if (temp->right)",
      "                {",
      "                    nextLevel.push(temp->right);",
      "                }",
      "                if (temp->left)",
      "                {",
      "                    nextLevel.push(temp->left);",
      "                }",
      "            }",
      "        }",
      "        if (currLevel.empty())",
      "        {",
      "            leftToRight = !leftToRight;",
      "            swap(currLevel, nextLevel);",
      "        }",
      "    }",
      "}"
    ],
    "description": "zigzagTraversal Bst"
  }
}
