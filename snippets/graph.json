{
  "Adjacency Matrix in Graph": {
    "prefix": "adjMatrix",
    "body": [
      "void adjMatrix()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    int adj[n + 1][n + 1];",
      "    for (int i = 0; i <= n; i++)",
      "    {",
      "        for (int j = 0; j <= n; j++)",
      "        {",
      "            adj[i][j] = 0;",
      "        }",
      "    }",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u][v] = 1;",
      "        adj[v][u] = 1;",
      "    }",
      "    for (int i = 0; i <= n; i++)",
      "    {",
      "        for (int j = 0; j <= n; j++)",
      "        {",
      "            cout << adj[i][j] << \" \";",
      "        }",
      "        cout << endl;",
      "    }",
      "}"
    ],
    "description": "Adjacency Matrix in Graph"
  },
  "Adjacency List in Graph": {
    "prefix": "adjList",
    "body": [
      "void adjList()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<vector<int>> adj(n);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        adj[v].pb(u);",
      "    }",
      "    for (int i = 0; i < adj.size(); i++)",
      "    {",
      "        cout << i << \"->\";",
      "        for (auto x : adj[i])",
      "        {",
      "            cout << x << \" \";",
      "        }",
      "        cout << endl;",
      "    }",
      "}"
    ],
    "description": "Adjacency List in Graph"
  },
  "BFS in Graph": {
    "prefix": "bfs",
    "body": [
      "void BFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n + 1, false);",
      "    vector<vector<int>> adj(n + 1);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        adj[v].pb(u);",
      "    }",
      "    queue<int> q;",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i])",
      "        {",
      "",
      "            q.push(i);",
      "            vis[i] = true;",
      "            while (!q.empty())",
      "            {",
      "                int node = q.front();",
      "",
      "                q.pop();",
      "                cout << node << \" \";",
      "                for (auto x : adj[node])",
      "                {",
      "                    if (!vis[x])",
      "                    {",
      "                        vis[x] = true;",
      "                        q.push(x);",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "BFS in Graph"
  },
  "DFS in Graph": {
    "prefix": "dfs",
    "body": [
      "void dfs(int node, vector<vector<int>> adj, vector<bool> &vis)",
      "{",
      "    vis[node] = true;",
      "    cout << node << \" \";",
      "    for (auto x : adj[node])",
      "    {",
      "        if (vis[x])",
      "        {",
      "            ;",
      "        }",
      "        else",
      "        {",
      "            dfs(x, adj, vis);",
      "        }",
      "    }",
      "}",
      "void DFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n + 1, false);",
      "    vector<vector<int>> adj(n + 1);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        adj[v].pb(u);",
      "    }",
      "",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i])",
      "        {",
      "",
      "            dfs(i, adj, vis);",
      "        }",
      "    }",
      "}"
    ],
    "description": "DFS in Graph"
  },
  "Topological BFS in Graph": {
    "prefix": "topoBfs",
    "body": [
      "void TopoBFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<vector<int>> adj(n);",
      "    vector<int> indeg(n, 0);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        indeg[v]++;",
      "    }",
      "    queue<int> q;",
      "    for (int i = 0; i < indeg.size(); i++)",
      "    {",
      "        if (indeg[i] == 0)",
      "        {",
      "            q.push(i);",
      "        }",
      "    }",
      "",
      "    while (!q.empty())",
      "    {",
      "        int node = q.front();",
      "",
      "        q.pop();",
      "        cout << node << \" \";",
      "        for (auto x : adj[node])",
      "        {",
      "            indeg[x]--;",
      "            if (indeg[x] == 0)",
      "            {",
      "                q.push(x);",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Topological BFS in Graph"
  },
  "Topological DFS in Graph": {
    "prefix": "topoDfs",
    "body": [
      "void Topodfs(int node, vector<vector<int>> adj, vector<bool> &vis, stack<int> &st)",
      "{",
      "    vis[node] = true;",
      "    for (auto x : adj[node])",
      "    {",
      "        if (vis[x])",
      "        {",
      "            ;",
      "        }",
      "        else",
      "        {",
      "            Topodfs(x, adj, vis, st);",
      "        }",
      "    }",
      "    st.push(node);",
      "}",
      "void TopoDFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n + 1, false);",
      "    vector<vector<int>> adj(n + 1);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "    }",
      "    stack<int> st;",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i])",
      "        {",
      "",
      "            Topodfs(i, adj, vis, st);",
      "        }",
      "    }",
      "    while (!st.empty())",
      "    {",
      "        int ans = st.top();",
      "        cout << ans << \" \";",
      "        st.pop();",
      "    }",
      "}"
    ],
    "description": "Topological DFS in Graph"
  },
  "Is Cycle is Present in Graph using DFS": {
    "prefix": "isCycleDfs",
    "body": [
      "bool isCycle(int s, vector<vector<int>> &adj, vector<bool> &vis, int parent)",
      "{",
      "    vis[s] = true;",
      "    for (auto x : adj[s])",
      "    {",
      "        if (x != parent)",
      "        {",
      "            if (vis[x])",
      "            {",
      "                return true;",
      "            }",
      "            if (!vis[x] && isCycle(x, adj, vis, s))",
      "            {",
      "                return true;",
      "            }",
      "        }",
      "    }",
      "    return false;",
      "}",
      "void CycleDFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n, false);",
      "    vector<vector<int>> adj(n);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "    }",
      "",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i] && isCycle(i, adj, vis, -1))",
      "        {",
      "",
      "            cout << true << endl;",
      "            return;",
      "        }",
      "    }",
      "    cout << false << endl;",
      "}"
    ],
    "description": "Is Cycle is Present in Graph using DFS"
  },
  "Is Cycle is Present in Graph using BFS": {
    "prefix": "isCycleBfs",
    "body": [
      "void CycleBFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<vector<int>> adj(n);",
      "    vector<int> indeg(n, 0);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        indeg[v]++;",
      "    }",
      "    queue<int> q;",
      "    for (int i = 0; i < indeg.size(); i++)",
      "    {",
      "        if (indeg[i] == 0)",
      "        {",
      "            q.push(i);",
      "        }",
      "    }",
      "    int count = 0;",
      "    while (!q.empty())",
      "    {",
      "        int node = q.front();",
      "",
      "        q.pop();",
      "        for (auto x : adj[node])",
      "        {",
      "            indeg[x]--;",
      "            if (indeg[x] == 0)",
      "            {",
      "                q.push(x);",
      "            }",
      "        }",
      "    }",
      "    if (count != n)",
      "    {",
      "        cout << true << endl;",
      "    }",
      "    else",
      "    {",
      "        cout << false << endl;",
      "    }",
      "}"
    ],
    "description": "Is Cycle is Present in Graph using BFS"
  },
  "Shortest Path Direct Acyclic Graph": {
    "prefix": "shortesPathDAG",
    "body": [
      "void TopodfsDAG(int node, vector<pair<int, int>> adj[], vector<bool> &vis, stack<int> &st)",
      "{",
      "    vis[node] = true;",
      "    for (auto x : adj[node])",
      "    {",
      "        if (!vis[x.first])",
      "        {",
      "            TopodfsDAG(x.first, adj, vis, st);",
      "        }",
      "    }",
      "    st.push(node);",
      "}",
      "void shortesPathDAG()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n + 1, false);",
      "    vector<pair<int, int>> adj[n];",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v, w;",
      "        cin >> u >> v >> w;",
      "        adj[u].pb({v, w});",
      "    }",
      "    int src;",
      "    cin >> src;",
      "    stack<int> st;",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i])",
      "        {",
      "",
      "            TopodfsDAG(i, adj, vis, st);",
      "        }",
      "    }",
      "    int dist[n];",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        dist[i] = INT_MAX;",
      "    }",
      "    dist[src] = 0;",
      "    while (!st.empty())",
      "    {",
      "        int node = st.top();",
      "        st.pop();",
      "        if (dist[node] != INT_MAX)",
      "        {",
      "            for (auto x : adj[node])",
      "            {",
      "                if (dist[x.first] > dist[node] + x.second)",
      "                {",
      "                    dist[x.first] = dist[node] + x.second;",
      "                }",
      "            }",
      "        }",
      "    }",
      "    for (int i = 0; i < n; i++)",
      "        (dist[i] == INT_MAX) ? cout << \"INFINITY \" : cout << dist[i] << \" \";",
      "}"
    ],
    "description": "Shortest Path Direct Acyclic Graph"
  },
  "Dijsktra Algorithm": {
    "prefix": "dijsktra",
    "body": [
      "void dijsktra()",
      "{",
      "    int n, m, source;",
      "    cin >> n >> m;",
      "    vector<pair<int, int>> g[n + 1];",
      "",
      "    int a, b, wt;",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        cin >> a >> b >> wt;",
      "        g[a].push_back(make_pair(b, wt));",
      "        g[b].push_back(make_pair(a, wt));",
      "    }",
      "    cin >> source;",
      "",
      "    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
      "    vector<int> disTo(n + 1, INT_MAX);",
      "",
      "    disTo[source] = 0;",
      "",
      "    pq.push(make_pair(0, source));",
      "",
      "    while (!pq.empty())",
      "    {",
      "        int dist = pq.top().first;",
      "        int prev = pq.top().second;",
      "        pq.pop();",
      "",
      "        vector<pair<int, int>>::iterator it;",
      "",
      "        for (it = g[prev].begin(); it != g[prev].end(); it++)",
      "        {",
      "            int next = it->first;",
      "            int nextDist = it->second;",
      "",
      "            if (disTo[next] > disTo[prev] + nextDist)",
      "            {",
      "                disTo[next] = disTo[prev] + nextDist;",
      "                pq.push(make_pair(disTo[next], next));",
      "            }",
      "        }",
      "    }",
      "    cout << \"The distances from source, \" << source << \", are : \" << endl;",
      "    for (int i = 1; i <= n; i++)",
      "    {",
      "        cout << disTo[i] << \" \";",
      "    }",
      "    cout << endl;",
      "}"
    ],
    "description": "Dijsktra Algorithm"
  },
  "BellmanFord Algorithm": {
    "prefix": "bellmanFord",
    "body": [
      "void bellmanFord()",
      "{",
      "    int N, m;",
      "    cin >> N >> m;",
      "    vector<node> edges;",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v, wt;",
      "        cin >> u >> v >> wt;",
      "        edges.push_back(node(u, v, wt));",
      "    }",
      "    int src;",
      "    cin >> src;",
      "",
      "    int inf = 1e9;",
      "    vector<int> dist(N, inf);",
      "    dist[src] = 0;",
      "",
      "    for (int i = 0; i <= N - 1; i++)",
      "    {",
      "        for (auto it : edges)",
      "        {",
      "            if (dist[it.u] + it.wt < dist[it.v])",
      "            {",
      "                dist[it.v] = dist[it.u] + it.wt;",
      "            }",
      "        }",
      "    }",
      "    int fl = 0;",
      "    for (auto it : edges)",
      "    {",
      "        if (dist[it.u] + it.wt < dist[it.v])",
      "        {",
      "            cout << \"NegativeCycle\" << endl;",
      "            fl = 1;",
      "            break;",
      "        }",
      "    }",
      "    if (!fl)",
      "    {",
      "        for (int i = 0; i < N; i++)",
      "        {",
      "            cout << i << \" \" << dist[i] << endl;",
      "        }",
      "    }",
      "}"
    ],
    "description": "BellmanFord Algorithm"
  }
}
