{
  "Tree Structure": {
    "prefix": "tstruct",
    "body": [
      "struct Node",
      "{",
      "    int data;",
      "    Node *left;",
      "    Node *right;",
      "",
      "    Node(int k)",
      "    {",
      "        data = k;",
      "        left = right = NULL;",
      "    }",
      "};"
    ],
    "description": "Tree Structure"
  },
  "Tree Inorder": {
    "prefix": "inorder",
    "body": [
      "void inOrder(Node *temp)",
      "{",
      "    if (temp != NULL)",
      "    {",
      "        inOrder(temp->left);",
      "        cout << temp->data << ' ';",
      "        inOrder(temp->right);",
      "    }",
      "}"
    ],
    "description": "Tree Inorder"
  },
  "Tree Preorder": {
    "prefix": "preorder",
    "body": [
      "void preOrder(Node *temp)",
      "{",
      "    if (temp != NULL)",
      "    {",
      "        cout << temp->data << ' ';",
      "        preOrder(temp->left);",
      "        preOrder(temp->right);",
      "    }",
      "}"
    ],
    "description": "Tree Preorder"
  },
  "Tree Postorder": {
    "prefix": "postorder",
    "body": [
      "int c = 0;",
      "void postOrder(Node *temp)",
      "{",
      "    if (temp != NULL)",
      "    {",
      "        postOrder(temp->left);",
      "        postOrder(temp->right);",
      "        cout << temp->data << ' ';",
      "        if (temp->right == NULL && temp->left == NULL)",
      "        {",
      "            c++;",
      "        }",
      "    }",
      "}"
    ],
    "description": "Tree Postorder"
  },
  "Level Order Traversal Tree": {
    "prefix": "levelOrder",
    "body": [
      "void levelOrder(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return;",
      "    }",
      "    queue<Node *> q;",
      "",
      "    q.push(root);",
      "    q.push(NULL);",
      "",
      "    while (!q.empty())",
      "    {",
      "        Node *node = q.front();",
      "        q.pop();",
      "",
      "        if (node != NULL)",
      "        {",
      "            cout << node->data << \" \";",
      "            if (node->left)",
      "            {",
      "                q.push(node->left);",
      "            }",
      "            if (node->right)",
      "            {",
      "                q.push(node->right);",
      "            }",
      "        }",
      "        else if (!q.empty())",
      "        {",
      "            q.push(NULL);",
      "        }",
      "    }",
      "}"
    ],
    "description": "Level Order Traversal Tree"
  },
  "Tree Size": {
    "prefix": "treeSize",
    "body": [
      "int getSize(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return 0;",
      "    }",
      "    return 1 + getSize(root->left) + getSize(root->right);",
      "}"
    ],
    "description": "Tree Size"
  },
  "Tree Height": {
    "prefix": "treeHeight",
    "body": [
      "int height(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return 0;",
      "    }",
      "    return max(height(root->left), height(root->right)) + 1;",
      "}"
    ],
    "description": "Tree Height"
  },
  "Tree Simple Diameter": {
    "prefix": "treeDiaSimple",
    "body": [
      "int diameter(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return 0;",
      "    }",
      "",
      "    int currDiameter = height(root->left) + height(root->right) + 1;",
      "",
      "    int lD = diameter(root->left);",
      "    int rD = diameter(root->right);",
      "",
      "    return max(currDiameter, max(lD, rD));",
      "}"
    ],
    "description": "Tree Simple Diameter"
  },
  "Tree Optimized Diameter": {
    "prefix": "treeDiaOpt",
    "body": [
      "int optDiameter(Node *root, int *ht)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        *ht = 0;",
      "        return 0;",
      "    }",
      "",
      "    int lh = 0, rh = 0;",
      "",
      "    int lD = optDiameter(root->left, &lh);",
      "    int rD = optDiameter(root->right, &rh);",
      "    int currDiameter = lh + rh + 1;",
      "    *ht = max(lh, rh) + 1;",
      "",
      "    return max(currDiameter, max(lD, rD));",
      "}"
    ],
    "description": "Tree Optimized Diameter"
  },
  "Tree Node Sum": {
    "prefix": "treeSum",
    "body": [
      "int getSum(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return 0;",
      "    }",
      "    return getSum(root->left) + getSum(root->right) + root->data;",
      "}"
    ],
    "description": "Tree Node Sum"
  },
  "Tree Node Maximum": {
    "prefix": "treeMax",
    "body": [
      "int MAX(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return INT_MIN;",
      "    }",
      "",
      "    return max(root->data, max(MAX(root->left), MAX(root->right)));",
      "}"
    ],
    "description": "Tree Node Maximum"
  },
  "Tree Right View": {
    "prefix": "treeRightView",
    "body": [
      "void rightView(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return;",
      "    }",
      "    queue<Node *> q;",
      "    q.push(root);",
      "",
      "    while (!q.empty())",
      "    {",
      "        int n = q.size();",
      "        for (int i = 0; i < n; i++)",
      "        {",
      "            Node *curr = q.front();",
      "            q.pop();",
      "",
      "            if (i == n - 1)",
      "            {",
      "                cout << curr->data << \" \";",
      "            }",
      "            if (curr->left != NULL)",
      "            {",
      "                q.push(curr->left);",
      "            }",
      "            if (curr->right != NULL)",
      "            {",
      "                q.push(curr->right);",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Tree Right View"
  },
  "Tree Left View": {
    "prefix": "treeLeftView",
    "body": [
      "void leftView(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return;",
      "    }",
      "    queue<Node *> q;",
      "    q.push(root);",
      "",
      "    while (!q.empty())",
      "    {",
      "        int n = q.size();",
      "        for (int i = 1; i <= n; i++)",
      "        {",
      "            Node *curr = q.front();",
      "            q.pop();",
      "",
      "            if (i == 1)",
      "            {",
      "                cout << curr->data << \" \";",
      "            }",
      "            if (curr->left != NULL)",
      "            {",
      "                q.push(curr->left);",
      "            }",
      "            if (curr->right != NULL)",
      "            {",
      "                q.push(curr->right);",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Tree Left View"
  },
  "Tree Balanced or Not Simple": {
    "prefix": "isBalancedSimple",
    "body": [
      "bool isBalanced(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return true;",
      "    }",
      "    if (isBalanced(root->left) == false)",
      "    {",
      "        return false;",
      "    }",
      "    if (isBalanced(root->right) == false)",
      "    {",
      "        return false;",
      "    }",
      "    if (abs(height(root->left) - height(root->right)) <= 1)",
      "    {",
      "        return true;",
      "    }",
      "    else",
      "    {",
      "        return false;",
      "    }",
      "}"
    ],
    "description": "Tree Balanced or Not Simple"
  },
  "Tree Balanced or Not Optimized": {
    "prefix": "isBalancedOpt",
    "body": [
      "bool isOptBalanced(Node *root, int *ht)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return true;",
      "    }",
      "    int lh = 0, rh = 0;",
      "    if (isOptBalanced(root->left, &lh) == false)",
      "    {",
      "        return false;",
      "    }",
      "    if (isOptBalanced(root->right, &rh) == false)",
      "    {",
      "        return false;",
      "    }",
      "    *ht = max(lh, rh) + 1;",
      "    if (abs(lh - rh) <= 1)",
      "    {",
      "        return true;",
      "    }",
      "    else",
      "    {",
      "        return false;",
      "    }",
      "}"
    ],
    "description": "Tree Balanced or Not Optimized"
  },
  "Flatten Binary Tree": {
    "prefix": "flatten",
    "body": [
      "void flatten(Node *root)",
      "{",
      "    if (root == NULL || (root->left == NULL || root->right == NULL))",
      "    {",
      "        return;",
      "    }",
      "",
      "    if (root->left != NULL)",
      "    {",
      "        flatten(root->left);",
      "",
      "        Node *temp = root->right;",
      "        root->right = root->left;",
      "        root->left = NULL;",
      "",
      "        Node *t = root->right;",
      "",
      "        while (t->right != NULL)",
      "        {",
      "            t = t->right;",
      "        }",
      "        t->right = temp;",
      "    }",
      "    flatten(root->right);",
      "}"
    ],
    "description": "Flatten Binary Tree"
  }
}
